# 文本编辑器最终修复说明

## 核心问题分析

### 问题症状
1. **字号显示不同步**：拖动滑块或输入新值后，输入框显示的是旧值
2. **状态混乱**：编辑状态和显示状态冲突
3. **useEffect 循环依赖**：`isEditingFontSize` 既在依赖项中，又在 effect 中被修改

### 根本原因

**错误的 useEffect 设计：**
```tsx
// ❌ 问题代码
useEffect(() => {
  if (!isEditingFontSize && currentTextLayer) {
    setFontSizeInput(String(currentTextLayer.style.fontSize));
  }
}, [currentTextLayer?.id, currentTextLayer?.style.fontSize, isEditingFontSize]);
//                                                          ^^^^^^^^^^^^^^^^
//                                          这个依赖项导致了循环和混乱
```

**问题分解：**
1. 用户拖动滑块 → store 更新 → `currentTextLayer.style.fontSize` 改变
2. 触发 useEffect → 但此时 `isEditingFontSize` 在依赖项中
3. 如果 `isEditingFontSize` 为 true，effect 不执行
4. 如果 `isEditingFontSize` 为 false，effect 执行但会与后续状态变化冲突

**核心矛盾：**
- `isEditingFontSize` 是**输入框的编辑状态**
- `currentTextLayer.style.fontSize` 是**store 的数据状态**
- 两者不应该在同一个 effect 中产生依赖关系

---

## 正确的解决方案

### 核心思路

**分离关注点：**
1. **数据同步 effect**：只关心 store → 本地 state 的同步
2. **状态重置 effect**：只关心图层切换时的状态清理

### 实现代码

```tsx
// ✅ 正确实现

// Effect 1: 数据同步（store → 本地 state）
// 只在非编辑状态时同步，避免覆盖用户输入
useEffect(() => {
  if (currentTextLayer && !isEditingFontSize) {
    setFontSizeInput(String(currentTextLayer.style.fontSize));
  }
}, [currentTextLayer?.id, currentTextLayer?.style.fontSize]);
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//  只依赖数据变化，不依赖编辑状态

// Effect 2: 状态重置（图层切换时）
// 切换图层时，强制退出编辑状态
useEffect(() => {
  setIsEditingFontSize(false);
}, [currentTextLayer?.id]);
//  ^^^^^^^^^^^^^^^^^^^^
//  只在图层切换时触发
```

---

## 工作流程详解

### 场景 1：拖动滑块

```
┌─────────────────────────────────────────────────────┐
│ 1. 用户拖动滑块                                       │
├─────────────────────────────────────────────────────┤
│ onChange → handleFontSizeChange(48)                 │
│   ↓                                                  │
│ updateLayer → store.fontSize = 48                   │
│   ↓                                                  │
│ store 改变 → 触发组件重渲染                          │
│   ↓                                                  │
│ useEffect 1 检测到 fontSize 改变                     │
│   ↓                                                  │
│ isEditingFontSize = false (用户没在编辑输入框)       │
│   ↓                                                  │
│ setFontSizeInput("48")                              │
│   ↓                                                  │
│ 输入框显示 48 ✓                                      │
└─────────────────────────────────────────────────────┘
```

### 场景 2：输入框编辑

```
┌─────────────────────────────────────────────────────┐
│ 1. 用户点击输入框                                     │
├─────────────────────────────────────────────────────┤
│ onFocus → setIsEditingFontSize(true)                │
│         → setFontSizeInput("32")  // 保存当前值    │
│   ↓                                                  │
│ 2. 用户输入 "1"                                      │
│   ↓                                                  │
│ onChange → setFontSizeInput("1")  // 只更新本地     │
│   ↓                                                  │
│ 输入框显示 "1"                                       │
│   ↓                                                  │
│ useEffect 1 检测到 fontSize 未变化，不触发           │
│   ↓                                                  │
│ 3. 用户继续输入 "80"                                 │
│   ↓                                                  │
│ onChange → setFontSizeInput("180")                  │
│   ↓                                                  │
│ 输入框显示 "180"                                     │
│   ↓                                                  │
│ 4. 用户按 Enter 或失焦                               │
│   ↓                                                  │
│ onBlur → setIsEditingFontSize(false)                │
│        → handleFontSizeChange(180)                  │
│   ↓                                                  │
│ store.fontSize = 180                                │
│   ↓                                                  │
│ useEffect 1 触发 → setFontSizeInput("180")          │
│   ↓                                                  │
│ 输入框显示 180 ✓                                     │
└─────────────────────────────────────────────────────┘
```

### 场景 3：混合操作（先滑块，后输入）

```
┌─────────────────────────────────────────────────────┐
│ 1. 拖动滑块到 60                                      │
├─────────────────────────────────────────────────────┤
│ store.fontSize = 60                                 │
│   ↓                                                  │
│ useEffect 1 → setFontSizeInput("60")                │
│   ↓                                                  │
│ 输入框显示 60 ✓                                      │
│   ↓                                                  │
│ 2. 点击输入框                                         │
│   ↓                                                  │
│ onFocus → setIsEditingFontSize(true)                │
│         → setFontSizeInput("60")  // 记录当前值    │
│   ↓                                                  │
│ 输入框显示 60（正确） ✓                              │
│   ↓                                                  │
│ 3. 输入 "100"                                        │
│   ↓                                                  │
│ 输入框显示 "100"                                     │
│   ↓                                                  │
│ 4. 按 Enter                                          │
│   ↓                                                  │
│ store.fontSize = 100                                │
│   ↓                                                  │
│ useEffect 1 → setFontSizeInput("100")               │
│   ↓                                                  │
│ 输入框显示 100 ✓                                     │
└─────────────────────────────────────────────────────┘
```

### 场景 4：切换图层

```
┌─────────────────────────────────────────────────────┐
│ 1. 图层 A (fontSize=32) 正在编辑输入框               │
├─────────────────────────────────────────────────────┤
│ isEditingFontSize = true                            │
│ fontSizeInput = "50" (用户输入中)                    │
│   ↓                                                  │
│ 2. 切换到图层 B (fontSize=64)                        │
│   ↓                                                  │
│ currentTextLayer.id 改变                            │
│   ↓                                                  │
│ useEffect 2 触发 → setIsEditingFontSize(false)      │
│   ↓                                                  │
│ useEffect 1 触发 → setFontSizeInput("64")           │
│   ↓                                                  │
│ 输入框显示 64（图层 B 的值） ✓                       │
│   ↓                                                  │
│ 3. 切回图层 A                                        │
│   ↓                                                  │
│ useEffect 1 → setFontSizeInput("32")                │
│   ↓                                                  │
│ 输入框显示 32（图层 A 的值） ✓                       │
└─────────────────────────────────────────────────────┘
```

---

## 关键设计原则

### 1. 单一职责

每个 effect 只做一件事：
- **Effect 1**：数据同步
- **Effect 2**：状态重置

### 2. 最小依赖

只依赖真正需要响应的数据：
- Effect 1 依赖：`currentTextLayer?.id`, `currentTextLayer?.style.fontSize`
- Effect 2 依赖：`currentTextLayer?.id`

### 3. 条件保护

在 effect 内部使用条件判断，而不是在依赖项中：
```tsx
// ✅ 好的做法
useEffect(() => {
  if (currentTextLayer && !isEditingFontSize) {
    // ...
  }
}, [currentTextLayer?.id, currentTextLayer?.style.fontSize]);

// ❌ 坏的做法
useEffect(() => {
  // ...
}, [currentTextLayer?.id, currentTextLayer?.style.fontSize, isEditingFontSize]);
```

### 4. 状态隔离

编辑状态（`isEditingFontSize`）和数据状态（`fontSize`）独立管理：
- **编辑状态**：控制输入框的行为
- **数据状态**：来自 store，通过 effect 同步到本地

---

## 测试验证

### ✅ 测试清单

#### 基础功能
- [ ] 拖动滑块 → 输入框实时更新
- [ ] 输入框输入大数值（如 180）→ 可以完整输入
- [ ] 输入框按 Enter → 立即生效并显示
- [ ] 输入框按 Escape → 恢复原值

#### 边界情况
- [ ] 输入超出范围（如 300）→ 自动限制为 200
- [ ] 输入小于最小值（如 5）→ 自动限制为 12
- [ ] 输入空值 → 不报错，失焦后恢复原值

#### 组合操作
- [ ] 滑块 → 输入框 → 滑块 → 值始终同步
- [ ] 快速连续拖动滑块 → 输入框跟随
- [ ] 编辑输入框时拖动滑块 → 输入框退出编辑

#### 图层切换
- [ ] 编辑图层 A → 切换到图层 B → 输入框显示图层 B 的值
- [ ] 图层 A 输入中 → 切换图层 → 输入被取消，显示新图层值

---

## 性能优化

### 已实现的优化

1. **useMemo 缓存颜色转换**
   ```tsx
   const hexColor = useMemo(() => {
     // rgba → hex 转换
   }, [currentTextLayer?.style.fill]);
   ```

2. **条件性 effect 执行**
   ```tsx
   if (currentTextLayer && !isEditingFontSize) {
     // 只在必要时执行
   }
   ```

3. **最小依赖项**
   避免不必要的 effect 触发

### 未来可考虑的优化

如果出现性能问题，可以添加：

1. **防抖滑块**
   ```tsx
   const debouncedFontSizeChange = useMemo(
     () => debounce(handleFontSizeChange, 16), // 60fps
     [currentTextLayer?.id]
   );
   ```

2. **虚拟化渲染**
   如果图层数量很多，考虑虚拟列表

---

## 总结

### 修复前的问题
- ❌ useEffect 循环依赖
- ❌ 编辑状态和数据状态混淆
- ❌ 输入框显示不同步
- ❌ 图层切换时状态残留

### 修复后的优势
- ✅ 清晰的职责分离
- ✅ 稳定的状态同步
- ✅ 正确的输入体验
- ✅ 可靠的图层切换

### 核心改进
**两个独立的 effect，各司其职：**
1. 数据同步 effect：响应 store 变化
2. 状态重置 effect：响应图层切换

这是一个典型的 React Hooks 最佳实践案例！
