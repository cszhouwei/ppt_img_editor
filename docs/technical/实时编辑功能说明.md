# 实时编辑功能说明

## 功能概述

文本编辑器现在支持**实时预览**，任何修改立即生效，无需点击"应用更改"按钮。

## 改进前后对比

### 旧版本工作流程 ❌

```
1. 选择文本图层
2. 修改文本内容
3. 调整字号
4. 修改颜色
5. 点击"应用更改"按钮 ← 额外步骤
6. 查看效果
```

**问题：**
- 需要额外操作
- 无法实时预览
- 容易忘记点击按钮，导致修改未保存

### 新版本工作流程 ✅

```
1. 选择文本图层
2. 修改文本内容 → 立即生效 ⚡
3. 调整字号       → 立即生效 ⚡
4. 修改颜色       → 立即生效 ⚡
```

**优势：**
- 所见即所得
- 减少操作步骤
- 提升编辑体验

---

## 技术实现

### 架构变更

#### 旧实现：双缓冲模式

```tsx
// 问题：需要维护本地 state 和 store 的同步
const [text, setText] = useState('');
const [fontSize, setFontSize] = useState(32);

// 1. 用户修改 → 更新本地 state
onChange={(e) => setText(e.target.value)}

// 2. 点击按钮 → 同步到 store
onClick={() => updateLayer(id, { text })}
```

**缺点：**
- 两份数据源（state 和 store）
- 同步逻辑复杂
- 容易出现不一致

#### 新实现：直接操作 store

```tsx
// 优势：单一数据源，直接操作 store
const handleTextChange = (newText: string) => {
  updateLayer(currentTextLayer.id, { text: newText });
};

// 用户修改 → 直接更新 store → UI 自动刷新
onChange={(e) => handleTextChange(e.target.value)}
```

**优点：**
- 单一数据源（store）
- 无需同步逻辑
- 实时响应

---

## 实现细节

### 1. 移除本地 State

```tsx
// ❌ 旧版本：使用本地 state
const [text, setText] = useState('');
const [fontSize, setFontSize] = useState(32);
const [fontWeight, setFontWeight] = useState(400);
const [color, setColor] = useState('#1e1e1e');

// ✅ 新版本：直接使用 store 数据
const currentTextLayer = useEditorStore((state) => state.selectedLayer);
// 无需本地 state
```

### 2. 实时更新处理器

每个可编辑属性都有对应的处理器：

```tsx
// 文本内容
const handleTextChange = (newText: string) => {
  if (!currentTextLayer) return;
  updateLayer(currentTextLayer.id, { text: newText });
};

// 字号
const handleFontSizeChange = (newSize: number) => {
  if (!currentTextLayer) return;
  updateLayer(currentTextLayer.id, {
    style: { ...currentTextLayer.style, fontSize: newSize }
  });
};

// 字重
const handleFontWeightChange = (newWeight: number) => {
  if (!currentTextLayer) return;
  updateLayer(currentTextLayer.id, {
    style: { ...currentTextLayer.style, fontWeight: newWeight }
  });
};

// 颜色
const handleColorChange = (newColor: string) => {
  if (!currentTextLayer) return;
  const r = parseInt(newColor.slice(1, 3), 16);
  const g = parseInt(newColor.slice(3, 5), 16);
  const b = parseInt(newColor.slice(5, 7), 16);

  updateLayer(currentTextLayer.id, {
    style: { ...currentTextLayer.style, fill: `rgba(${r},${g},${b},1)` }
  });
};
```

### 3. 受控组件绑定

所有输入组件直接绑定 store 数据：

```tsx
<textarea
  value={currentTextLayer.text}  // 从 store 读取
  onChange={(e) => handleTextChange(e.target.value)}  // 实时更新
/>

<input
  type="range"
  value={currentTextLayer.style.fontSize}  // 从 store 读取
  onChange={(e) => handleFontSizeChange(Number(e.target.value))}
/>
```

### 4. 颜色格式转换

由于 `<input type="color">` 使用 hex 格式，而 store 使用 rgba 格式，需要转换：

```tsx
// rgba → hex（用于显示）
const getHexColor = (): string => {
  const match = currentTextLayer.style.fill.match(/rgba?\((\d+),(\d+),(\d+)/);
  if (match) {
    const r = parseInt(match[1]).toString(16).padStart(2, '0');
    const g = parseInt(match[2]).toString(16).padStart(2, '0');
    const b = parseInt(match[3]).toString(16).padStart(2, '0');
    return `#${r}${g}${b}`;
  }
  return '#1e1e1e';
};

// hex → rgba（用于存储）
const handleColorChange = (hexColor: string) => {
  const r = parseInt(hexColor.slice(1, 3), 16);
  const g = parseInt(hexColor.slice(3, 5), 16);
  const b = parseInt(hexColor.slice(5, 7), 16);
  // ... 更新 store
};
```

---

## 性能优化

### 潜在问题

实时更新可能导致频繁的 store 更新和重渲染，特别是：
- 拖动滑块（连续触发 onChange）
- 输入文本（每个字符都触发）

### 优化方案（如需要）

#### 1. 防抖（Debounce）

适用于文本输入：

```tsx
import { useMemo } from 'react';
import { debounce } from 'lodash-es';

const debouncedTextChange = useMemo(
  () => debounce((text: string) => {
    updateLayer(currentTextLayer.id, { text });
  }, 300),  // 300ms 延迟
  [currentTextLayer?.id]
);

<textarea onChange={(e) => debouncedTextChange(e.target.value)} />
```

#### 2. 节流（Throttle）

适用于滑块：

```tsx
import { throttle } from 'lodash-es';

const throttledFontSizeChange = useMemo(
  () => throttle((size: number) => {
    updateLayer(currentTextLayer.id, { style: { fontSize: size } });
  }, 100),  // 每 100ms 最多更新一次
  [currentTextLayer?.id]
);

<input type="range" onChange={(e) => throttledFontSizeChange(Number(e.target.value))} />
```

#### 3. requestAnimationFrame

适用于高频更新：

```tsx
const rafIdRef = useRef<number | null>(null);

const handleFontSizeChange = (size: number) => {
  if (rafIdRef.current) {
    cancelAnimationFrame(rafIdRef.current);
  }

  rafIdRef.current = requestAnimationFrame(() => {
    updateLayer(currentTextLayer.id, { style: { fontSize: size } });
  });
};
```

**当前状态：** 暂未实施优化，先观察实际性能。如果出现卡顿，再应用上述优化。

---

## 用户体验改进

### 1. 即时反馈

```
用户操作 → 立即在画布上看到效果
```

**示例：**
- 拖动字号滑块：文字大小实时变化
- 修改文本：输入的同时画布更新
- 切换颜色：颜色选择器打开时即可预览

### 2. 减少认知负担

```
旧版：修改 → 记住修改 → 点击按钮 → 确认生效
新版：修改 → 生效 ✓
```

### 3. 探索式编辑

实时预览鼓励用户尝试不同的样式：

```
快速尝试多种字号 → 找到最合适的
```

---

## 测试场景

### 基础功能测试

1. **文本编辑**
   - 输入文字 → 画布实时更新
   - 删除文字 → 画布实时更新
   - 换行 → 画布正确显示

2. **字号调整**
   - 拖动滑块 → 文字大小实时变化
   - 输入数字 → 文字大小立即更新
   - 边界值（12, 200）→ 正确限制

3. **字重切换**
   - 切换 Normal/Semi-bold/Bold → 立即生效

4. **颜色修改**
   - 选择颜色 → 文字颜色实时改变
   - hex 格式正确显示

### 边界测试

1. **快速连续操作**
   - 快速拖动滑块 → 不卡顿
   - 快速输入文字 → 不丢失字符

2. **切换图层**
   - 选择图层 A → 修改
   - 切换到图层 B → 修改
   - 切回图层 A → 显示正确

3. **空值处理**
   - 清空文本 → 不报错
   - 字号为 0 → 自动限制为 12

---

## 兼容性

### 向后兼容

- 不影响已有数据
- Store 结构未变更
- 其他组件无需修改

### 浏览器兼容

- Chrome/Edge: ✅ 完全支持
- Firefox: ✅ 完全支持
- Safari: ✅ 完全支持
- IE11: ❌ 不支持（但项目本身不支持 IE11）

---

## 未来优化

### 1. 撤销/重做

实时编辑需要更智能的撤销栈：

```tsx
// 当前：每次修改都记录
// 问题：输入"Hello"会产生 5 条历史记录

// 优化：合并连续的文本修改
// 结果：输入"Hello"只产生 1 条历史记录
```

### 2. 批量编辑

选中多个文本图层，统一修改样式：

```tsx
const selectedLayers = useEditorStore((state) => state.selectedLayers);

const handleBatchFontSizeChange = (size: number) => {
  selectedLayers.forEach(layer => {
    if (layer.kind === 'text') {
      updateLayer(layer.id, { style: { fontSize: size } });
    }
  });
};
```

### 3. 样式预设

快速应用预设样式：

```tsx
const presets = {
  title: { fontSize: 48, fontWeight: 700, fill: 'rgba(0,0,0,1)' },
  body: { fontSize: 16, fontWeight: 400, fill: 'rgba(80,80,80,1)' },
  caption: { fontSize: 12, fontWeight: 400, fill: 'rgba(150,150,150,1)' }
};

<button onClick={() => applyPreset('title')}>标题样式</button>
```

### 4. 键盘快捷键

```
Cmd/Ctrl + B: 加粗
Cmd/Ctrl + I: 斜体
Cmd/Ctrl + ↑: 增大字号
Cmd/Ctrl + ↓: 减小字号
```

---

## 总结

实时编辑功能通过**移除中间状态**和**直接操作 store**，实现了所见即所得的编辑体验。这不仅简化了代码结构，也大幅提升了用户体验。
